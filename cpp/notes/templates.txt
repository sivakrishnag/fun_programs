Introduction to Templates

Templates are used for Generic programming. That means we can write
algorithms and classes without regards to the data type.
Let us understand it with example.

int Max(int x, int y)
{
  return x > y ? x : y;
}

int main() {
  auto num = Max(3, 5);
  std::cout << num << std::endl;
  return 0;
}

This function compares two integer variables x and y and returns the largest value.
If we also want to find the Max of two floats or two doubles, then we will have
to write a function for each datatype. Obviously we can overload the Max
function for a specific datatype.

float Max(float x, float y)
{
  return x > y ? x : y;
}

int main() {
  auto num = Max(3.3f, 5.8f);
  std::cout << num << std::endl;
  return 0;
}

If we want to find the Max of some other type, then we will need to overload
the Max function for that type. This is going to be tedious.
It will lead to large number of functions.
This is where c++ templates can step in.

Templates allow us to write a function that can operate on any kind of
datatype.

Let us go ahead and convert this Max function into a function template.
Any kind of template always begin with the keyword template. Then you have to
specify the place holder for the types. And that is specified as typename and
some name (say T).

     template<typename T>

This T is the placeholder for the type and this T will be substituted by the
actual type whereever used during the compilation time.

In some books we may see the keyword class being used in place of typename.
And in this context there is no difference between the usage of class and
typename.
Both declare a name that is used as a placeholder for the type.
The differences between classname and typename are apparent only when we do
advanced template programming. But for our case we can use typename instead of
class.

The Max function written using templates will look like below:

    template<typename T>
    T Max (T x, T y)
    {
      return x > y ? x : y;
    }

    int main ()
    {
      auto num_f = Max(3.3f, 5.8f);
      auto num_i = Max(3, 5);
      std::cout << num_f << std::endl;
      std::cout << num_i << std::endl;
      return 0;
    }

Here we did not have to write a function for each type. Instead the compiler
will automatically generate the function for appropriate type. The compiler
will examine the function calls and accordingly will deduce the type of T.
In the case of "auto num_f = Max(3.3f, 5.8f)", the type T is deduced to float
and in the other case, the type T is deduced to int.

That is why compiler will generate two copies of Max function. One will be for
float and other will be for integer type. 

This means that if the function template is not invoked, then the function is
not generated by the compiler. 
The compiler will generate the function only for those types with which it is
invoked. The process by which the function is generated is called as
instantiation. 
The compiler will examine the arguments of the function template and it will
accordingly deduce the type of T. Once the type of T is deduced, the function
will be instantiated for that type. 


Summary:
Using templates,
   - Generalize software components
   - Such components can be reused in different situations
   - Operate on any kind of data
   - High performance algorithms & classes
   - Compile time; no runtime costs are involved
   - Libraries such as ATL, WTL, Boost, POCO, ACE, etc. use templates for
     implementation

Function templates
   - Function that accepts template type arguments
   - Always begin with template keyword
   - Template type argument is called type name
   - Type name is a placeholder for the actual type
   - Can accept any type
   - The template type can be used as return type

       Template parameter list
             |
             V
template<typename T>
T Function(T arg) {
 // Implementation
}
